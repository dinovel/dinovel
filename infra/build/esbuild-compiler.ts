import { denoPlugin } from "https://deno.land/x/esbuild_deno_loader@0.6.0/mod.ts";
import { initialize, build, BuildResult as ESBuildResult, BuildOptions, BuildFailure } from "https://deno.land/x/esbuild@v0.15.13/mod.js";
import { parse } from 'deno/path/mod.ts';
import { Subject } from 'rxjs';

import { ICompiler } from "./compiler.ts";
import { IReporter } from "./reporter.ts";
import { BuildResult, BuildWatcher } from "./target.ts";

export type ESBuildParser = {
  initialize: typeof initialize;
  build: typeof build;
};

export class EsbuildCompiler implements ICompiler {
  #report: IReporter;
  #hasInit = false;
  #esParser: ESBuildParser;

  constructor(report: IReporter, esParser?: ESBuildParser) {
    this.#report = report;
    this.#esParser = esParser ?? {
      initialize,
      build,
    };
  }

  compile(file: URL, optimize: boolean, watch?: false|undefined): Promise<BuildResult>;
  compile(file: URL, optimize: boolean, watch: true): Promise<BuildWatcher>;
  async compile(file: URL , optimize: boolean, watch?: boolean): Promise<BuildResult | BuildWatcher> {
    const bundleOptions = this.#buildOptions(file, optimize);

    await this.#init();

    let subject: Subject<BuildResult> | undefined = undefined;
    if (watch) {
      subject = new Subject<BuildResult>();
      bundleOptions.watch = {
        onRebuild: (error: BuildFailure | null, result: ESBuildResult | null) => {
          if (error) {
            this.#report.stderr('ESBuild', error.name);
            this.#report.stderr('ESBuild', error.message);
            subject?.next({
              input: file,
              success: false,
              errors: error.errors.map(e => JSON.stringify(e)),
              warns: error.warnings.map(e => JSON.stringify(e)),
              output: '',
            });
            return;
          }

          if (result) {
            subject?.next(this.#parseResult(result, file));
          }
        }
      }
    }


    const res = await this.#esParser.build(bundleOptions);

    if (subject) {
      return {
        result: this.#parseResult(res, file),
        watch: subject,
        stop: () => {
          subject?.complete();
          res.stop?.();
        }
      }
    } else {
      return this.#parseResult(res, file);
    }
  }

  #buildOptions(file: URL, optimize: boolean): BuildOptions {
    const importMapURL = new URL('./import_map.json', Deno.mainModule);

    return {
      entryPoints: { [parse(file.href).name]: file.href },
      bundle: true,
      format: "esm",
      metafile: true,
      minify: optimize,
      outdir: ".",
      absWorkingDir: Deno.cwd(),
      outfile: "",
      platform: "neutral",
      plugins: [denoPlugin({ importMapURL })],
      splitting: false,
      target: ["chrome99", "firefox99", "safari15"],
      treeShaking: true,
      write: false,
      incremental: true,
      charset: 'utf8',
      banner: { js: '// File generated by DINOVEL' },
      keepNames: false,
      logLevel: 'warning',
      logLimit: 50,
      sourceRoot: parse(file.href).dir,
      sourcemap: optimize ? 'inline' : false,
    }
  }

  async #init(): Promise<void> {
    if (!this.#hasInit) {
      await this.#esParser.initialize({});
      this.#hasInit = true;
    }
  }

  #parseResult(result: ESBuildResult, input: URL): BuildResult {
    return {
      input,
      success: true,
      output: result.outputFiles![0].text,
      errors: result.errors.map(e => JSON.stringify(e)),
      warns: result.warnings.map(e => JSON.stringify(e)),
    };
  }
}
